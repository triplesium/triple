module;
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <string_view>

export module triple.refl:type;
import triple.base;

namespace triple::refl {

export class TypeData {
  public:
    explicit constexpr TypeData() : m_name("") {}
    explicit constexpr TypeData(
        std::string_view name,
        std::size_t size
    ) noexcept : m_name(name), m_size(size) {}
    ~TypeData() = default;

    TypeData(TypeData&) = delete;
    TypeData& operator=(const TypeData&) = delete;
    TypeData(TypeData&&) = delete;

    constexpr std::string_view name() const { return m_name; }
    constexpr std::size_t size() const { return m_size; }

  private:
    constexpr TypeData(int) : m_name("Type") {}

  private:
    std::string_view m_name;
    std::size_t m_size;
};

export class Type {
  public:
    constexpr Type(const TypeData& data) : m_data(&data) {}
    // Type(std::nullptr_t) : m_data(nullptr) {}

    Type(Type&&) = default;
    Type(const Type& other) = default;
    Type& operator=(Type&&) = default;
    Type& operator=(const Type&) = default;

    constexpr auto operator<=>(const Type& other) const {
        return hash() <=> other.hash();
    }
    constexpr auto operator==(const Type& other) const {
        return hash() == other.hash();
    }

    constexpr std::string_view name() const {
        auto last_colon = m_data->name().find_last_of(':');
        if (last_colon != std::string_view::npos)
            return m_data->name().substr(last_colon + 1);
        else
            return m_data->name();
    }

    constexpr std::string_view full_name() const { return m_data->name(); }

    constexpr std::size_t size() const { return m_data->size(); }

    constexpr std::size_t hash() const { return crc32(full_name()); }

  private:
    const TypeData* m_data;
};

} // namespace triple::refl

namespace std {
export template<>
struct hash<triple::refl::Type> {
    std::size_t operator()(const triple::refl::Type& type) const {
        return type.hash();
    }
};
} // namespace std
