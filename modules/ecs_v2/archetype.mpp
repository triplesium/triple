module;
#include <algorithm>
#include <any>
#include <cassert>
#include <cstdint>
#include <cstdlib>
#include <tuple>
#include <unordered_map>
#include <vector>

export module triple.ecs.v2:archetype;
import triple.refl;
import triple.base;
import :entity;
import :utils;
import :column;
import :fwd;

namespace triple::ecs::v2 {

std::size_t hash_type_vector(const std::vector<refl::Type>& types) {
    std::size_t seed = types.size();
    for (auto& type : types) {
        auto x = type.hash();
        x = ((x >> 16) ^ x) * 0x45d9f3b;
        x = ((x >> 16) ^ x) * 0x45d9f3b;
        x = (x >> 16) ^ x;
        seed ^= x + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }
    return seed;
}

export struct Edges {
    std::unordered_map<refl::Type, ArchetypeId> remove;
    std::unordered_map<refl::Type, ArchetypeId> add;
};

export class Archetype {
  public:
    Archetype(ArchetypeId id, std::vector<refl::Type> components) :
        m_id(id), m_components(std::move(components)) {
        // std::ranges::sort(m_components);
        std::sort(m_components.begin(), m_components.end());
        for (auto& component : m_components) {
            m_columns.try_emplace(component, component.size());
        }
    }

    std::size_t size() const { return m_entities.size(); }

    std::size_t alloc(Entity entity) {
        auto row = m_entities.size();
        m_entities.push_back(entity);
        for (auto& [type, column] : m_columns) {
            column.push_back(nullptr);
        }
        return row;
    }

    void remove_row(std::size_t row) {
        for (auto& [type, column] : m_columns) {
            column.swap_remove(row);
        }
        m_entities[row] = m_entities.back();
        m_entities.pop_back();
    }

    refl::Ref get_component(refl::Type component_type, std::size_t row) {
        if (!m_columns.contains(component_type))
            return nullptr;
        return refl::Ref {
            m_columns.at(component_type).get(row),
            component_type
        };
    }

    void
    set_component(refl::Type component_type, std::size_t row, refl::Ref value) {
        if (!m_columns.contains(component_type))
            return;
        m_columns.at(component_type).set(row, value.address());
    }

    bool has_component(refl::Type component_type) const {
        return m_columns.contains(component_type);
    }

    Entity entity(std::size_t row) const { return m_entities[row]; }

    std::size_t hash() const { return hash_type_vector(m_components); }

    const std::vector<refl::Type>& components() const { return m_components; }

    Edges& edges() { return m_edges; }

    ArchetypeId id() const { return m_id; }

  private:
    ArchetypeId m_id;
    std::vector<Entity> m_entities;
    std::vector<refl::Type> m_components;
    std::unordered_map<refl::Type, Column> m_columns;
    Edges m_edges;
};

export class Archetypes {
  public:
    // WARNING: This may invalidate reference to Archetype
    ArchetypeId get_id_or_insert(std::vector<refl::Type> components) {
        std::sort(components.begin(), components.end());
        auto hash = hash_type_vector(components);
        auto it = by_components.find(hash);
        if (it != by_components.end()) {
            return it->second;
        }
        auto id = (ArchetypeId)m_archetypes.size();
        m_archetypes.emplace_back(id, std::move(components));
        by_components[hash] = id;
        return id;
    }

    Archetype& get(ArchetypeId id) {
        assert(id < m_archetypes.size());
        return m_archetypes[id];
    }

    std::vector<Archetype>& archetypes() { return m_archetypes; }
    const std::vector<Archetype>& archetypes() const { return m_archetypes; }

  private:
    std::vector<Archetype> m_archetypes;
    std::unordered_map<std::size_t, ArchetypeId> by_components;
};

} // namespace triple::ecs::v2
